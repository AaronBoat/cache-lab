# part A 思路
## LRU实现：
cache的每一行 额外存储一份 **时间戳**：
    进入时候初始化为0
    每次有进入缓存，都扫描，将所有 valid 的行 时间戳都++
    （工程细节：为了减少判断次数，进入时候先把 set 所有valid 时间戳普遍++，再把自身时间戳置零）
    查询的时候，寻找当前 set 最大的时间戳对应的行地址
    （可能的优化： 在进入的时候动态维护每个set的LRU 地址，进入额外开销为1；如果每次搜索，每个行经过 e次就会出去，均摊下来好像常数级别优化）

## 命中情况判断
    遍历，找到了则 hit ； 否则 miss
    miss 时候如果set 还有空的行则是冷不命中，放入即可
    若已经没有 valid = 0 的行，则容量未命中， 需要eviction

## 命令行参数
    主程序读取

## 结果截图
![alt text](image.png)